# 6.4.1. 並行最佳化

一開始，我們將會在本節討論兩個個別的議題，其實際上需要對立的最佳化。一個多執行緒應用程式在一些它的執行緒中使用共有的資料。一般的快取最佳化要求將資料保存在一起，使得應用程式的記憶體使用量很小，從而最大化在任意時間塞得進快取的記憶體總量。[^譯註1]

不過，使用這個方法有個問題：若是多條執行緒寫入到一個記憶體位置，每個相對應核心的 L1d 中的快取行必須處於「E」（獨占）狀態。這表示會送出許多的 RFO 訊息。在最糟的情況下，每次寫入存取都會送出一個訊息。所以一個普通的寫入將會突然變得非常昂貴。若是使用了相同的記憶體位置，同步就是必須的（可能透過原子操作的使用，其會在下個章節討論到）。不過，當所有執行緒都使用了不同的記憶體位置、並且可能是獨立的時候，問題也顯而易見。

<figure>
  <img src="../../assets/figure-6.10.png" alt="圖 6.10：並行快取行存取的間接成本">
  <figcaption>圖 6.10：並行快取行存取的間接成本</figcaption>
</figure>

圖 6.10 顯示了這種「假共享（false sharing）」的結果。測試程式（顯示於 A.3 節）建立了若干執行緒，其除了遞增一個記憶體位置（5 億次）外什麼也不做。量測的時間是從程式啟動、直到程式等待最後一條執行緒結束之後。執行緒被釘在獨立的處理器上。機器擁有四個 P4 處理器。藍色值表示被指派到每條執行緒的記憶體分配位在個別快取行上的執行時間。紅色部分為執行緒的位置被移到僅一個快取行時出現的損失。

藍色的量測（使用獨立的快取行時所需的時間）與預期的相符。程式在無損失的情況下延展至多條執行緒。每個處理器都將它的快取行保存在它擁有的 L1d 中，而且沒有頻寬問題，因為不必讀取太多程式碼或資料（事實上，它們全都被快取了）。量測的些微提升其實是系統的雜訊、和可能的一些預取影響（執行緒使用連續的快取行）。

使用唯一一個快取行所需的時間、以及每條執行緒一個個別的快取行所需的時間相除所計算出的量測的間接成本分別是 390%、734%、以及 1,147%。乍看之下，這些很大的數字可能很令人吃驚，但考慮到需要的快取交互影響，這應該很顯而易見。已經完成寫入到快取行之後，就從一個處理器的快取拉出快取行。[^譯註2]在任何給定的時刻，除了擁有快取行的處理器以外，所有處理器都會被延遲，無法做任何事。每個額外的處理器都會導致更多的延遲。



[^譯註1]: 因為快取的最小單位為快取行。因此若是資料擺在一起，代表它們所佔用的快取行數量較少，因此一次能快取的資料量就變多了。

[^譯註2]: 因為所有執行緒寫入的資料都在同個快取行內。因此剛寫入的快取行立刻就會因為其它執行緒也要對相同的快取行進行寫入，而變為「I（無效）」狀態。

