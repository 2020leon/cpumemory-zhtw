# 6.3.2. 軟體預取

硬體預取的優勢在於不必調整程式。缺點如同方才描述的，存取模式必須很直觀，而且預取無法橫跨分頁邊界進行。因為這些原因，我們現在有了更多可能性，軟體預取它們之中最重要的。軟體預取不需藉由插入特殊的指令來修改原始碼。某些編譯器支援編譯指示（pragma）以或多或少地自動插入預取指令。
On x86 and x86-64 Intel’s convention for compiler intrinsics to insert these special instructions is generally used:

```c
#include <xmmintrin.h>
enum _mm_hint
{
  _MM_HINT_T0 = 3,
  _MM_HINT_T1 = 2,
  _MM_HINT_T2 = 1,
  _MM_HINT_NTA = 0
};
void _mm_prefetch(void *p,
                  enum _mm_hint h);
```

程式能夠在程式中的任何指標上使用 `_mm_prefetch` 內部函數。許多處理器（當然包含所有 x86 與 x86-64 處理器）都會忽略無效指標產生的錯誤，這令程式設計師的生活好過非常多。若是被傳遞的指標指向合法的記憶體，會命令預取單元將資料載入到快取中，並且––必要的話––逐出其它資料。不必要的預取應該被確實地避免，因為這會降低快取的有效性，而且它會耗費記憶體頻寬（在被逐出的快取行是髒的情況下，可能需要兩個快取行的頻寬）。

要與 `_mm_prefetch` 一起使用的不同提示（hint）是由實作定義的。這表示每個處理器版本能夠（稍微）不同地實作它們。一般能說的是，`_MM_HINT_T0` 會為包含式快取將資料獲取到所有快取層級，並為獨占式快取獲取到最低層級的快取。若是資料項目在較高層級的快取中，它會被載入到 L1d 中。`_MM_HINT_T1` 提示將資料拉進 L2 而非 L1d。若是有個 L3 快取，`_MM_HINT_T2` 能做到類似於此的事情。不過，這些是沒怎麼被明確指定的細節，需要對所使用的實際處理器進行驗證。一般來說，若是資料在使用 `_MM_HINT_T0` 之後立刻被用到就沒錯了。當然這要求 L1d 快取大小要大得足以容納所有被預取的資料。若是立即被使用的工作集大小太大，將所有東西預取到 L1d 就是個壞點子，而應該使用其它兩種提示。

第四種提示，`_MM_HINT_NTA` 能夠吩咐處理器特殊地對待預取的快取行。NTA 代表非暫存對齊（non-temporal aligned），我們已經在 6.1 節解釋過了。程式告訴處理器應該盡可能地避免以這個資料污染快取，因為資料只在一段很短的期間內會被使用。對於包含式快取實作，處理器因而能夠在載入時避免將資料讀取進較低層級的快取。當資料從 L1d 逐出時，資料不必被推進 L2 或更高層級的快取中，但能夠直接寫到記憶體中。可能有其它處理器設計師在給定這個提示時能夠部屬的其它手法。程式設計師必須謹慎地使用這個提示：若是當前的工作集大小太大，並強制逐出以 NTA 提示載入的快取行，就要重新從記憶體載入。

<figure>
  <img src="../../assets/figure-6.7.png" alt="圖 6.7：使用預取的平均，NPAD=31">
  <figcaption>圖 6.7：使用預取的平均，NPAD=31</figcaption>
</figure>

圖 6.7 顯示了使用現已熟悉的指標追逐框架（pointer chasing framework）的測試結果。串列是隨機地被擺放在記憶體中的。與先前測試的不同之處在於，程式真的會在每個串列節點上花一些時間（大約 160 週期）。如同我們從圖 3.15 的數據中學到的，一旦工作集大小大於最末層快取，程式的效能就會受到嚴重的影響。

我們現在能夠試著在計算之前發出預取請求來改善這種狀況。即，我們在迴圈的每一輪預取一個新元素。串列中被預取的節點與正在處理的節點之間的距離必須被謹慎地選擇。假定每個節點在 160 週期內被處理、並且我們必須預取兩個快取行（`NPAD`=31），五個串列元素的距離便足夠了。

圖 6.7 的結果顯示了預取確實有幫助。只要工作集大小不超過最後一層快取的大小（這台機器擁有 512kB = 2<sup>19</sup>B 的 L2），數字就是相同的。預取指令並不會增加能量測出來的額外負擔。一旦超過 L2 大小，預取省下了 50 到 60 週期之間，高達 8%。預取的使用無法隱藏任何損失，但它稍微有點幫助。

