# 6.2.2. 最佳化一階指令快取存取

準備有效使用 L1d 的程式碼需要與有效使用 L1d 類似的技術。不過，問題是，程式設計師通常不會直接影響 L1i 的使用方式，除非她／他以組合語言來撰寫程式。若是使用了編譯器，程式設計師能夠透過引導編譯器建立更好的程式佈局，來間接地決定 L1i 的使用。

程式有跳躍[^譯註]間為線性的優點。在這些期間，處理器能夠有效地預取記憶體。跳轉（jump）打破了這個美好的想像，因為

* 跳轉目標（target）可能不是動態決定的；
* 而且即使它是靜態的，若是它錯失了所有快取，記憶體獲取可能會花上很長一段時間。

這些問題造成了執行中的停頓，可能嚴重地影響效能。這即是為何現今的處理器在分支預測（branch prediction，BP）上費盡心思的原因了。高度特製化的 BP 單元試著盡可能遠在跳轉之前確定跳轉的目標，使得處理器能夠開始將新的位置的指令載入到快取中。它們使用靜態與動態規則、而且越來越擅於判定執行中的模式。

對指令快取而言，盡早將資料拿到快取甚至是更為重要的。如同在 3.1 節提過的，指令必須在它們被執行之前解碼，而且––為了加速（在 x86 與 x86-64 上很重要）––指令實際上是以被解碼的形式、而非從記憶體讀取的位元組／字組的形式被快取的。

為了達到最好的 L1i 使用，程式設計師至少應該留意下述的程式碼產生的面向：

1. 盡可能地減少程式碼量（code footprint）。這必須與像是迴圈展開（loop unrolling）與行內展開（inlining）等最佳化取得平衡。
2. 程式執行應該是沒有氣泡（bubble）的線性的。[^31]
3. 合理的情況下，對齊程式碼。

（本節未完）



[^譯註]: 這裡的「跳躍」與下句的「跳轉」原文都是 jump。但根據前後文來看，前者指的似乎是一個指令接著一個指令循序執行，而後者指的是如條件分支、迴圈、函數呼叫等非循序的指令執行。因此在這裡翻譯為不同的詞彙，以示區隔。

[^31]: 氣泡生動地描述了在一個處理器的管線中執行的空洞，其會在執行必須等待資源的時候發生。關於更多細節，請讀者參閱處理器設計的文獻。

